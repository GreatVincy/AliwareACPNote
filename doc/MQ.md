+ 概念：消息队列，阿里云商用的专业消息中间件，是企业级互联网架构的核心产品，提供基于高可用分布式集群技术搭建的消息发布订阅、轨迹查询、资源统计、定时（延时）、监控报警等一系列消息云服务
+ 基于高可用分布式集群技术
+ MQ 历史超过9年
+ 异步解耦、削峰填谷的能力，同时具备海量消息堆积、高吞吐、可靠重试等互联网应用所需的特性
+ 单个域内采用多机房部署，可用性极高，无单点
+ 用户可以将应用部署在阿里云 ECS、企业自建云，或者嵌入到移动端、物联网设备中
+ 支持公网接入

+ 支持协议
 + HTTP: Restful, 跨语言
 + MQTT: 主动推送，多级 Topic 模型支持一次触达 1000万+ 终端（物联网、IM）
 + TCP: 专业、可靠、稳定

+ 管理工具
 + web 控制台: 支持 Topic 管理、发布管理、订阅管理、消息查询、消息轨迹、资源报表以及监控报警管理
 + Open API: 将 MQ 管理工具集成到自己的控制台
 + mqadmin命令集: 专有云输出提供一套丰富的管理命令集，以命令方式对 MQ 服务进行管理

+ 特色功能
 + 事务消息: 类似X/Open XA 的分布事务功能, 以达到事务最终一致性状态
 + 定时消息
 + 延时消息: （延时）投递，最长支持40天
 + 4MB大消息: 默认支持最大 256KB 消息，华北2 地域支持最大 4MB 消息
 + 消息轨迹: 定位排查问题
 + 广播消息
 + 顺序消息
 + 重置消费位点: 消息回溯或者丢弃堆积消息

 + 优势
  + 专业： 超过9年，保证不丢失，双11在用
  + 高可靠：
   + 一份消息多份落盘存储，经过严格的断电测试，消息依然保证不丢失。
   + 允许海量消息堆积，单个 Topic 可堆积 100亿+条消息，系统高流量压力下依然可靠
   + 默认消息持久化存储 3 天，支持重置消费位点消费3天之内任何时间点的消息。

  + 高性能
   + 同一网络内，消息传输网络时延在 10 毫秒之内，性能测试下，网卡可被打满
   + 默认单 Topic 发送消息上限为每秒 5000 条，最高可申请扩展至 10W 以上。
   + 默认单条消息大小最大支持 256KB，华北2 地域支持 4MB 大消息

  + 多协议接入
  + 独立部署

+ 应用场景
 + 领域: 包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、手游、视频、物联网、车联网等
 + 业务：
  + 一对多，多对多异步解耦，基于发布订阅模型，对分布式应用进行异步解耦，增加应用的水平扩展能力。
  + 削峰填谷，大促等流量洪流突然来袭时，MQ 可以缓冲突发流量，避免下游订阅系统因突发流量崩溃。
  + 日志监控，作为重要日志的监控通信管道，将应用日志监控对系统性能影响降到最低。
  + 消息推送，为社交应用和物联网应用提供点对点推送，一对多广播式推送的能力。
  + 金融报文，发送金融报文，实现金融准实时的报文传输，可靠安全。
  + 电信信令，将电信信令封装成消息，传递到各个控制终端，实现准实时控制和信息传递

+ Producer ID：一类 Producer 的标识，这类 Producer 通常生产并发送一类消息，且发送逻辑一致。
+ Consumer ID：一类 Consumer 的标识，这类 Consumer 通常接收并消费一类消息，且消费逻辑一致。
+ Producer实例和Consumer实例线程安全
+ 集群消费: 平摊消息
+ 广播消费: 各自消费
+ 顺序消息: MQ 提供的一种按照顺序进行发布和消费的消息类型, 分为全局顺序消息和分区顺序消息
+ 顺序发布: 对于指定的一个 Topic，客户端将按照一定的先后顺序进行发送消息。
+ 顺序消费: 对于指定的一个 Topic，按照一定的先后顺序进行接收消息，即先发送的消息一定会先被客户端接收到
+ 全局顺序消息:对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。
+ 分区顺序消息: 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 key 是完全不同的概念
+ 消息过滤:订阅者可以根据消息标签（Tag）对消息进行过滤，确保订阅者最终只接收被过滤后的消息类型, 消息过滤**在 MQ 服务端完成**
+ 中继: 中继服务（Relay）是由消息队列(MQ)提供的服务发布与订阅组件，该组件的主要作用是在不同的网络环境下实现服务之间互联互通的能力。
+ Topic 不能跨域使用。比如 Topic 创建在“华北 2”这个域，那么消息生产端和消费端也必须运行在“华北 2”的 ECS 上。
+ Topic 名只能包含字母数字_-,3-64字符，超过自动截取，创建后不能修改，且全局唯一
+ 建议创建不同的 Topic 来发送不同类型的消息
+ Producer ID/Consumer ID 必须全局唯一
+ Producer ID/Consumer ID必须和对应的 Topic 在同一个域
+ Producer ID 和 Topic 的关系是 1:N
+ Consumer ID 和 Topic 的关系是 N:N
+ key限制在32字节内
+ RAM (Resource Access Management) 是阿里云为客户提供的集中式访问控制服务，其核心功能主要包括用户身份与授权管理，应用场景可以覆盖企业子账号与分权管理、针对移动 APP 的临时授权管理，和不同组织之间的资源互操作与授权管理。
+ ` acs:<service-name>:<region>:<account-id>:<resource-relative-id>` => `acs:mq:*:1234567890123456:TopicA`
+ 定时/延时消息适用于如下一些场景：
 + 消息生产和消费有时间窗口要求：比如在电商交易中超时未支付关闭订单的场景，在订单创建时会发送一条 MQ 延时消息，这条消息将会在30分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。如支付未完成，则关闭订单，如已完成支付则忽略。
 + 通过消息触发一些定时任务，比如在某一固定时间点向用户发送提醒消息。

 + 定时/延时消息 msg.setStartDeliverTime 的参数需要设置成当前时间戳之后的某个时刻（单位毫秒），如果被设置成当前时间戳之前的某个时刻，消息将立刻投递给消费者。
 + 定时/延时消息 msg.setStartDeliverTime 的参数可设置40天内的任何时刻（单位毫秒），超过40天消息发送将失败。
 + StartDeliverTime 是服务端开始向消费端投递的时间。如果消费者当前有消息堆积，那么定时、延时消息会排在堆积消息后面，将不能严格按照配置的时间进行投递。
 + 由于客户端和服务端可能存在时间差，定时消息/延时消息的投递也可能与客户端设置的时间存在偏差。
 + 设置定时、延时消息的投递时间后，依然受 3 天的消息保存时长限制。例如，设置定时消息 5 天后才能被消费，如果第 5 天后一直没被消费，那么这条消息将在第8天被删除。
 + 除 TCP 协议接入的 Java 语言支持延时消息，其他方式都不支持延时消息。
 + 顺序消息由两个部分组成：顺序发布和顺序消费。
 + 分区顺序消息场景：
   + 用户注册需要发送发验证码，以用户 ID 作为 sharding key
   + 电商的订单创建，以订单 ID 作为 sharding key

+ 消息类型对比   

| Topic类型 | 支持事务消息 | 支持定时消息 | 性能 |
|:-                  |:-:                       |:-:                       |:-:      |
|  无序消息  |   是  |   是  |   最高  |
|  分区顺序  |   否  |   否  |     高    |
|  全局顺序  |   否  |   否  |   一般  |

+ 发送方式对比

| Topic类型 | 支持可靠同步发送 | 支持可靠异步发送 | 支持 Oneway 发送 |
|:-                  |:-:                       |:-:                       |:-:      |
|  无序消息  |   是  |   是  |    是   |
|  分区顺序  |   是  |   否  |    否   |
|  全局顺序  |   是  |   否  |    否   |

+ 顺序消息暂不支持广播模式。
+ 同一个 Producer ID 或者 Consumer ID 只能对应一种类型的 Topic，即不能同时用于顺序消息和无序消息的收发。
+ 顺序消息不支持异步发送方式，否则将无法严格保证顺序。
+ 对于全局顺序消息，建议实例个数>=2。同时运行多个实例的作用是为了防止工作实例意外退出时，业务中断。当工作实例退出时，其他实例可以立即接手工作，不会导致业务中断，实际同时工作的只会有一个实例。
+ 对于分区顺序，建议实例个数>=2，<=分区数。当工作实例退出时，其他实例可以立即接手工作，不会导致业务中断，每个实例平均分配分区数。

+ 半消息：暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息。
+ 消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回查。
+ 事务消息的 Producer ID 不能与其他类型消息的 Producer ID 共用。
+ 通过 ONSFactory.createTransactionProducer 创建事务消息的 Producer 时必须指定 LocalTransactionChecker 的实现类，处理异常情况下事务消息的回查。
+ 事务消息发送完成本地事务后，可在 execute 方法中返回如下三种状态：
 + TransactionStatus.CommitTransaction 提交事务，允许订阅方消费该消息。
 + TransactionStatus.RollbackTransaction 回滚事务，消息将被丢弃不允许消费。
 + TransactionStatus.Unknow 暂时无法判断状态，期待固定时间以后 MQ Server 向发送方进行消息回查

 ```
 message.putUserProperties(PropertyKeyConst.CheckImmunityTimeInSeconds,"120");
 // 以上方式只确定事务消息的第一次回查的最快时间，实际回查时间向后浮动0~5秒；如第一次回查后事务仍未提交，后续每隔5秒回查一次。
 ```
+ 集群：MQ 约定使用相同 Consumer ID 的订阅者属于同一个集群(消费逻辑必须完全一致)
+ 集群消费：当使用集群消费模式时，MQ 认为任意一条消息只需要被集群内的任意一个消费者处理即可。
+ 广播消费：当使用广播消费模式时，MQ 会将每条消息推送给集群内所有注册过的客户端，保证消息至少被每台机器消费一次。
+ 集群消费进度在服务端维护，可靠性更高
+ 集群消费模式下，不保证消息的每一次失败重投等逻辑都能路由到同一台机器上，因此处理消息时不应该做任何确定性假设。
+ 广播模式下，MQ 保证每条消息至少被每台客户端消费一次，但是并不会对消费失败的消息进行失败重投，因此业务方需要关注消费失败的情况
+ 广播模式下，第一次启动时默认从最新消息消费，客户端的消费进度是被持久化在客户端本地的隐藏文件中，因此不建议删除该隐藏文件，否则会丢失部分消息。
+ 目前仅 Java 客户端支持广播模式。
+ 广播模式下服务端不维护消费进度，所以 MQ 控制台不支持消息堆积查询和堆积报警功能。
+ 使用集群模式模拟广播：创建多个 Consumer ID，用于订阅同一个 Topic　　　
 + 消费进度在服务端维护，可靠性高于广播模式
 + 每台机器的逻辑可以相同也可以不一样。
 + 一个个云账户所能创建的 Consumer ID 数量是有限制的   

+ MQ 允许消费者按照 Tag 对消息进行过滤, 在服务端完成消息过滤
+ 在多个 Tag 之间用 || 分隔
+ 同一个消费者多次订阅某 Topic 下的不同 Tag，后者会覆盖前者
+ MQ 里的一个 Consumer ID 代表一个 Consumer 实例群组。对于大多数分布式应用来说，一个 Consumer ID 下通常会挂载多个 Consumer 实例。订阅关系一致指的是同一个 Consumer ID 下所有 Consumer 实例的处理逻辑必须完全一致。一旦订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失。
 + 订阅的 Topic 必须一致(Topic、Topic数量)
 + 订阅的 Topic 中的 Tag 必须一致(Tag、Tag数量)

+ MQ 消息重试只针对集群消费方式生效
+ MQ 默认允许每条消息最多重试 16 次
+ 如果消息重试 16 次后仍然失败，消息将不再投递。
+ 一条消息无论重试多少次，这些重试消息的 Message ID 不会改变   


 ```   
 //方式1：返回 Action.ReconsumeLater，消息将重试（推荐）   
       return Action.ReconsumeLater;   
 //方式2：返回 null，消息将重试
       return null;
 //方式3：直接抛出异常， 消息将重试
       throw new RuntimeException("Consumer Message exceotion");

 //消息处理正常，直接返回 Action.CommitMessage;
return Action.CommitMessage;

 //配置对应 Consumer ID 的最大消息重试次数为20 次
properties.put(PropertyKeyConst.MaxReconsumeTimes,"20");

//获取消息的重试次数
System.out.println(message.getReconsumeTimes());
```


+ 最大重试次数大于16次，超过16次的重试时间间隔均为每次2小时。
+ 消息最大重试次数的设置对相同 Consumer ID 下的所有 Consumer 实例有效。
+ 如果只对相同 Consumer ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效。
+ 配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置。
+ 以业务唯一标识作为幂等处理的关键依据（key）--消息幂等处理（因为可能会发生消息重复）
+  Topic， Producer ID， Consumer ID，需要到 MQ 控制台上创建
+ 目前 TCP 协议接入方式提供 Java， C/C++，.NET 的 SDK
+ 消息发送的超时时间，单位（毫秒），默认：3000
+ Consumer 实例的消费线程数，默认：64
+ 每条消息消费的最大超时时间，默认：15
+ MQ 的 TCP Java SDK 基于 SLF4J 接口编程，客户端日志的打印依赖用户在配置文件中指定的日志实现。目前支持 log4j（暂不支持log4j2）、logback
+ MQ 发送消息有三种实现方式：可靠同步发送、可靠异步发送、单向(Oneway)发送。
+ 可靠同步发送
 + 同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方式。
 + 此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。
 + SendResult sendResult = producer.send(msg); // 同步发送消息，只要不抛异常就是成功

+ 可靠异步发送
 + 异步发送是指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式
 + 异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。
 + producer.sendAsync(msg, callback)

+ 单向（Oneway）发送
 + 单向（Oneway）发送特点为只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。
 + 用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。
 + 不会重试，可能丢失
 + producer.sendOneway(msg);

+ 多线程发送：跟普通线程一样使用，Producer/Consumer实例线程安全
+ 请避免为每个线程创建一个客户端实例
+ 消息队列 HTTP 协议将于 2018.04.01 起逐步下线
+ 消息队列遥测传输（Message Queuing Telemetry Transport，简称 MQTT）是一种轻量的，基于发布订阅模型的即时通讯协议。该协议设计开放，协议简单，平台支持丰富，几乎可以把所有联网物品和外部连接起来，因此在移动互联网和物联网领域拥有众多优势。
 + 使用发布/订阅消息模式，提供一对多的消息分发，解除了应用程序之间的耦合；
 + 对负载内容屏蔽的消息传输；
 + 使用 TCP/IP 提供基础的网络连接；
 + 有三种级别的消息传递服务；
 + 小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。

+ MQ 完整支持 MQTT 3.1.1 协议
+ MQTT 网关负责对用户的 MQTT 客户端提供服务，同时负责 MQTT 协议和后端 MQ 私有协议的转换
+ MQTT 作为移动互联网以及物联网领域的主流协议，应用场景丰富。目前 MQ 提供的 MQTT 服务已经在各个领域有所应用，覆盖了直播互动、车联网、金融支付、智能家居、即时聊天等多个场景。同时，MQTT 服务端采用分布式理念进行设计，系统无单点瓶颈，各个组件都可以无限水平扩展，保证容量可以随着您的在线使用量进行调整。
+ MQTT支持 SSL/TLS 加密通信
+ MQTT名词解释
 + Instance: 用户申请购买 MQTT 服务的实体单元，每个 MQTT 实例都对应一个全局唯一的服务接入点URL
 + Parent Topic: MQTT 协议基于 Pub/Sub 模型，因此任何消息都属于一个 Topic。根据 MQTT 协议，Topic 存在多级，定义第一级 Topic 为父 Topic（Parent Topic），使用 MQTT 前，该 Parent Topic 需要先在 MQ 控制台申请
 + Subtopic: MQTT 的二级 Topic，甚至三级 Topic 都是父 Topic 下的子类。使用时，直接在代码里设置，无需申请。需要注意的是 MQTT 限制 Parent Topic 和 Subtopic 的总长度为64个字符，如果超出长度限制将会导致客户端异常
 + Client ID: MQTT 的 Client ID 是每个客户端的唯一标识，要求全局唯一，使用相同的 Client ID 连接 MQTT 服务会被拒绝。Client ID 由两部分组成，组织形式为 GroupID@@@DeviceID。
 + GroupID: 用于指定一组逻辑功能完全一致的节点共用的组名，代表一类相同功能的设备。Group ID 需要在 MQ 控制台申请方可使用
 + Device ID: 每个设备独一无二的标识，由业务方自己指定。需要保证全局唯一，例如每个传感器设备的序列号。
 + Username: 设置为阿里云的 AccessKey 即可
 + Password: 将 GroupID 作为签名字段，SecretKey 作为秘钥，使用 HmacSHA1 算法计算签名字符串，并将签名字符串设置到 Password 参数中用于鉴权
 + ServerUrl: MQ 提供的 MQTT 服务的接入点 URL，都是公网 URL，目前 MQTT 的接入除了支持标准协议的1883端口，同时还支持加密 SSL，WebSocket，Flash 等方式。接入点URL是在申请实例之后自动分配
 + QoS: QoS （Quality of Service）指代消息传输的服务质量。它包括QoS0（最多分发一次）、QoS1（至少达到一次）和 QoS2（仅分发一次）三种级别。
 + cleanSession: 是 MQTT 协议中对一个客户端建立 TCP 连接后是否关心之前状态的定义。具体语义如下：
   + cleanSession=true：客户端再次上线时，将不再关心之前所有的订阅关系以及离线消息。
   + cleanSession=false：客户端再次上线时，还需要处理之前的离线消息，而之前的订阅关系也会持续生效。

+ MQTT 要求每个客户端每次连接时的 cleanSession 标志必须固定，不允许动态变化，否则会导致离线消息的判断有误。
+ MQTT 目前对外 QoS2 消息不支持非 cleanSession ，如果客户端以 QoS2 方式订阅消息，即使设置 cleanSession=false 也不会生效。
+ P2P 消息的 cleanSession 判断以发送方客户端的配置为准。
+ QoS 和 cleanSession 的不同组合产生的结果如下表所示：

|QoS级别 |cleanSession=true	|cleanSession=false|
|:-:|:-:|:-:|
|QoS0	|无离线消息，在线消息只尝试推一次  |无离线消息，在线消息只尝试推一次 |
|QoS1	|无离线消息，在线消息保证可达	         |有离线消息，所有消息保证可达         |
|QoS2	|无离线消息，在线消息保证只推一次	 |暂不支持                                                 |

+ MQTT端口：
 + 标准：1883
 + SSL: 8883
 + Websocket: 80
 + Websocket SSL: 443
 + Flash: 843

+ 使用 MQTT 时，一定要在对应的 Region 申请 Topic 资源，如果跨 Region 调用会收不到消息。

+ 新创建的 Consumer ID从哪里开始消费？
 + 如果这个 Consumer ID 是第一次启动，则会忽略启动之前发送的消息，也就是忽略历史消息，从启动之后发送的消息开始消费。
 + 如果这个 Consumer ID 是第二次启动，那么从上次消费的位置开始消费。
 + 如果想从特定位置开始消费，可以通过 MQ 控制台的消费位点重置功能，指定到具体的时间开始消费。每次重置只针对特定 Consumer ID 下的特定 Topic，不会影响其他 Consumer ID。

+ 广播消费方式仍然能保证一条消息至少被消费一次，但消费失败后不做重试操作。
+ 消息发送了，但是没有收到怎么办？
 + 使用 Topic 按时间范围进行查询，可以查询到一段时间内某 Topic 收到的所有消息。
 + 使用 Topic 和 Message ID 对消息进行精准查询。
 + 使用 Topic 和 Message Key 较为精准地查询具有相同 Message Key 的一类消息。

+ MQ 是否能保证消息不重复？
  + 绝大多数情况下，消息是不重复的。作为一款分布式消息中间件，在网络抖动、应用处理超时等异常情况下，无法保证消息不重复，但是能保证消息不丢失。

+ MQ 客户端如何设置消费线程数？
 + 在启动 Consumer 时，设置一个 ConsumeThreadNums 属性即可。具体示例如下所示：
 + properties.put(PropertyKeyConst.ConsumeThreadNums,20);

+ 当输入查询条件查不到轨迹数据时，请参考是否属于以下无法查询情况。
 + 消息轨迹目前支持 Java 客户端(版本至少为 1.2.2)，C++，.NET，和 HTTP 客户端。
 + 查询条件是否正确，Topic，Message ID，Message Key 是否输入正确。
 + 查询时间区间是否正确，为了提高查询速度，需要您输入消息的发送时间范围。如果查询不到，请尝试扩大时间范围重试。
 + 如果确认上述情况无误还是无法查询到结果，请提交工单获得技术支持，并附带上日志文件，日志文件位于/home/{user}/logs/ons.log。

+ 确定已经消费了消息，但轨迹却显示没有消费，而且客户端 IP 和 Producer ID 不符合实际情况?
  + 出现该现象是由于客户端本身并没有升级到支持轨迹功能的版本，因此 MQ 轨迹查询后端仅仅能够拿到部分不完整的轨迹数据，展现结果不正常。建议尽快升级客户端

+ 之前的查询任务怎么看不到了？
 + 为了防止历史查询任务太多，影响展示效果，MQ 会对用户的历史查询任务做定期清理，默认只保留7天以内的查询任务，如果出现历史任务看不到，请重新查询即可。

+ MQ 用户收到堆积告警后怎么办？
 + 如果发现消息堆积量很多，按以下步骤进行处理：
   + 首先排查下当前消息处理速度是不是比较慢，即检查消息写入速度是否大于消费速度，可以通过资源报表查询历史消费状态。如果确定消费速度跟不上，可以调整业务代码或者对消费者进行扩容。
   + 可以用 jstack 输出程序堆栈进行分析，检查消费是否有“卡住”现象（消费线程阻塞）。
  + 如果消息已经没有堆积，检查阈值是否设置过小导致消息堆积。可以在监控管理页面找到对应监控项进行编辑。

+ 顺序消息是否支持 HTTP 接入？
 + 支持顺序消息发送，暂不支持顺序消息消费。如需使用顺序消息消费可使用 TCP 方式接入。

+ 同一条消息是否可以既是顺序消息，同时又支持定时消息/事务消息？
 + 不行。顺序消息、定时消息、事务消息是不同的消息类型，三者是互斥关系，不能叠加在一起使用。

 + 顺序消息支持哪些 Region？
   + 支持 MQ 所有公共云 Region 和金融云 Region。

  + 无法连接 Broker
    + 您使用的阿里云云主机(ECS)与 MQ 所属服务器不在同一 Region；
    + 您可能在非阿里云主机上访问 MQ 服务，且您创建的 Topic 不支持非阿里云主机访问。
    + --
    + 请确保阿里云主机与创建的 Topic 在同一个 Region；
    + 非阿里云主机访问 MQ，请确保 Topic 所在区域为公网。

+ 启动 Producer、Consumer 失败，Group Name 重复
 + 在同一个 JVM 里面使用同一个 Producer ID/Consumer ID 配置了多个 Producer/Consumer 实例，导致客户端启动失败。
 + --
 + 确保一个 JVM 中对应的一个 Producer ID/Consumer ID 只配置一个 Producer/Consumer 实例；
重启应用。

+ 广播模式下，消费者启动加载 JSON 文件异常
 + Fastjson 版本太低导致广播消费者加载本地的 offsets.json 文件异常，导致启动失败。
 + --
 + 将 Fastjson 的版本升级到 ons-client 所依赖的版本，保证本地的 offsets.json 能够被正常加载。默认情况下 offsets.json 在 /home/{user}/.rocketmq_offsets/ 下。

+ 主动订阅消息，获取队列列表失败/Topic 不存在
 + 可能未在控制台上创建该 Topic，导致订阅方启动时获取 Topic 的队列信息失败

+ 发送消息失败
 + MQ Broker 向 Producer 返回了错误码，具体错误形式参见这个异常对应的嵌套异常；
 + MQ Broker 宕机后，Producer 还未发现最新的 Broker 列表，会短暂报此异常；
 + Producer 发送消息超时，一般由服务器压力过大或者网络不稳定导致。
 + --
 + 问题一般是短暂的，重试

+ 订阅组（Consumer Group）不存在
 + 未在控制台上创建该订阅组，导致使用该订阅组与 MQ Broker 创建连接的时候，服务器校验不通过。

+ 主机名不存在
 + 可能是无法正确获取主机名或者主机 IP 地址导致，请尝试使用此命令来证实：hostname
 + 如果无法正常输出，就说明确实是此原因；如果可以正常输出，可能是其他原因，请请提交工单获得技术支持。

+ 消息不合法
 + 消息为空；
 + 消息内容为空；
 + 消息内容长度为0；
 + 消息内容超过限定长度。

+ 参数不合法
 + consumeThreadMin Out of range [1, 1000]	消费端线程数设置不合理
 + consumeThreadMax Out of range [1, 1000]	消费端线程数设置不合理
 + messageListener is null	未设置messageListener
 + consumerGroup is null	未设置Consumer ID
 + msg delay time more than 40 day	定时消息延时不能超过40天

+ 客户端状态异常
 + 创建 Consumer、Producer 之后未调用 start() 方法来启动客户端；
 + 创建 Consumer、Producer 之后 start() 过程有异常导致客户端启动失败；
 + 创建 Consumer、Producer 并成功调用 start() 方法后，显式调用了 shutdown() 方法关闭了客户端。
